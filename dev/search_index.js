var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"[1] Neal, R. (2000). Markov chain sampling methods for Dirichlet process mixture models. Journal of Computational and Graphical Statistics, 9(2). https://doi.org/10.1080/10618600.2000.10474879","category":"page"},{"location":"library/#Library","page":"Library","title":"Library","text":"","category":"section"},{"location":"library/#Types","page":"Library","title":"Types","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"DPM","category":"page"},{"location":"library/#Accessors","page":"Library","title":"Accessors","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"n_clusters\nactive_clusters\npassive_clusters\ncluster_capacity\ncluster_labels\ncluster_sizes\ndp_mass","category":"page"},{"location":"library/#Interface","page":"Library","title":"Interface","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"parent_dpm(::AbstractModel)\nupdate_suffstats!(::AbstractModel, ::Any)\nupdate_suffstats!(::AbstractModel, ::Any, ::Int, ::Int, ::Int)\nupdate_hyperpars!\nlogpredlik","category":"page"},{"location":"create/#Creating-a-DPM","page":"Creating a DPM","title":"Creating a DPM","text":"","category":"section"},{"location":"create/","page":"Creating a DPM","title":"Creating a DPM","text":"The first step is to define a subtype of AbstractModel that extends the type DPM using composition, e.g.","category":"page"},{"location":"create/","page":"Creating a DPM","title":"Creating a DPM","text":"struct MyDPM <: AbstractModel\n    parent::DPM\n    # ... any desired fields\nend","category":"page"},{"location":"create/","page":"Creating a DPM","title":"Creating a DPM","text":"In this way, all the standard components of the DPM (e.g. the vector of cluster labels) will be stored in parent. Please, read carefully the documentation about DPM and its constructor/accessors in order to avoid redundancies.","category":"page"},{"location":"create/","page":"Creating a DPM","title":"Creating a DPM","text":"Once MyDPM is defined, the second and last step is to specialize the following methods to m::MyDPM:","category":"page"},{"location":"create/","page":"Creating a DPM","title":"Creating a DPM","text":"parent(m::MyDPM)\nupdate_suffstats!(m::MyDPM, data)\nupdate_suffstats!(m::MyDPM, data, i::Int, k0::Int, k1::Int)\nupdate_hyperpars!(rng::AbstractRNG, m::MyDPM, data)\nlogpredlik(m::MyDPM, data, i::Int, k::Int)","category":"page"},{"location":"create/","page":"Creating a DPM","title":"Creating a DPM","text":"see the documentation of each method for more details. Once again, we note that data can have any type, as long as each method is correctly implemented.","category":"page"},{"location":"start/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"start/","page":"Getting Started","title":"Getting Started","text":"Let m be an object of type MyDPM, where MyDPM <: AbstractModel conforms with the interface defined in this module. Then, m contains the current state of the chain associated with the Gibbs sampler described in Neal's algorithm 3. We can access the contents of m using the following accessors:","category":"page"},{"location":"start/","page":"Getting Started","title":"Getting Started","text":"julia> DPMNeal3.n_clusters(m)      # return the number of active clusters\njulia> DPMNeal3.active_clusters(m) # return the active clusters\njulia> DPMNeal3.cluster_labels(m)  # return the cluster labels\njulia> DPMNeal3.cluster_sizes(m)   # return the cluster sizes\njulia> DPMNeal3.dp_mass(m)         # return the DP mass parameter","category":"page"},{"location":"start/","page":"Getting Started","title":"Getting Started","text":"Now, let data be an object of type MyData, where MyData <: Any is the datatype of the sample expected by MyDPM. Then, we can perform one Gibbs update using update!():","category":"page"},{"location":"start/","page":"Getting Started","title":"Getting Started","text":"julia> rng = Random.MersenneTwister(1) # or any AbstractRNG object\njulia> update!(m, data)","category":"page"},{"location":"start/","page":"Getting Started","title":"Getting Started","text":"Note that data can have any type, provided that MyDPM conforms with the interface.","category":"page"},{"location":"install/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"Install with the Julia package manager Pkg:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"# Press ']' to enter the Pkg REPL mode.\npkg> add DPMNeal3","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"or","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"julia> using Pkg; \njulia> Pkg.add(\"DPMNeal3\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = DPMNeal3","category":"page"},{"location":"#DPMNeal3.jl","page":"Home","title":"DPMNeal3.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"DPMNeal3.jl provides an interface for Dirichlet process mixture (DPM) models in Julia using Neal's algorithm 3 [1]. Particularly, this package provides:","category":"page"},{"location":"","page":"Home","title":"Home","text":"A method for performing one iteration of Neal's algorithm 3.\nSeveral methods for accessing the current state of the chain (e.g. the vector of cluster labels).","category":"page"}]
}
